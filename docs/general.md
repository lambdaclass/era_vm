# General documentation

## Heaps/Aux Heaps and Fat Pointers.

How we manage them through page ids, when regular heaps are used and when aux heaps are used. Explain what a FatPointer is, what narrowing is.

## Far Calls vs Near Calls. CallFrames and Context

Explain the difference between the two, what information `CallFrame`s and `Context`s hold. Why `zksolc` wraps every far call in a near call to return the `success` boolean (with example assembly).

How far calls pass calldata and returndata between contracts through pointers. Explain the `get_memory_forward_pointer` function and its variants.

## Call Types

Regular, Mimic, and Delegate. Explain the differences between them and how MimicCalls are used to call constructors on behalf of the deployed contract.

## Precompiles and System calls

Explain how calls to precompiles work, use keccak as an example as it's used on every deployment (it goes to the `keccak.yul` contract which then uses the `precompile` opcode).
What are system contracts? What's a system call? Show some examples (deployer, nonce holder, L2BaseToken) and what they're used for.

## `context.get_context_u128` opcode, msg.value, payable functions

Explain what `msg.value` is in solidity, how that maps to `context.get_context_u128` and a small example showing how non-payable functions revert when `context.get_context_u128` is not set to zero on calls.

Show an example of the assembly generated by a function doing a `call` sending money and how it ends up calling the `MsgValueSimulator` (address `0x8009`, `32777` in decimal) which in turn calls the `L2BaseToken` contract. Something like this:

```
function sendMoney(address payable to) public payable {
  (bool success, bytes memory _data) = to.call{value: msg.value}("");
  require(success, "Failed to send Ether");
}
```

## Tracers and how to add prints

How tracer works, how the PrintTracer works, how to add prints when running contracts.

## Difference between a revert and a panic; exception handlers

Talk about what a revert and a panic are; what specifically can trigger a panic inside the VM. What's an exception handler? How are they managed on `CallFrame`s? Show some assembly example.

## Bootloader

TODO
Operator execution (transactions come in, get executed on the bootloader, state is suspended until new transaction shows up).
