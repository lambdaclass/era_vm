# General documentation

## Heaps/Aux Heaps and Fat Pointers.

How we manage them through page ids, when regular heaps are used and when aux heaps are used. Explain what a FatPointer is, what narrowing is.

## Far Calls vs Near Calls. CallFrames and Context

Far Calls are the equivalent of calls in the EVM, they are used to call external contracts. Near Calls are used to call internal functions within the same contract that is being executed.

Contracts have their own unique `Context` which itself can hold multiple `CallFrame`s. `CallFrame`s are used to keep track of the current state of the contract being executed.

#### When a Far Call is made, a new `Context` is created and pushed into the running `Context`s of the vm. `Context`s are composed of:

- Contract `Address`
- Caller `Address`
- Code `Address`
- Code Page
- `Stack`
- Running `CallFrame`s (created by Near Calls)
- `Heap`
- `AuxHeap`
- `CalldataHeap`

The amount of gas that can be allocated to a new `Context` is limited to 64/64 of the currently available gas in the running `Context`.

**A new Near Call will inherit the properties of the current `CallFrame`, and make use of the `Stack` and `Heap`s of the running `Context`**.

#### `CallFrame`s are composed of:

- Available gas
- Exemption handler
- Stack Pointer
- Program Counter

### Far Call wrapping

Let's look at the following solidity code:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LibraryContract {
    function someFunction() public {}
}

contract CallerContract {
    LibraryContract libraryContract;

    constructor(address _libraryContractAddress) {
        libraryContract = LibraryContract(_libraryContractAddress);
    }

    function callNonReturningFunction() public {
        libraryContract.someFunction();
    }
}
```

Here we are calling a function of an external contract, this should net us a `far_call` instruction on our compiled code.

Compiling this code with `zksolc` gives us (part of) the following assembly:

```assembly
.text
	.file	"test.sol:CallerContract"
	.globl	__entry
__entry:
.func_begin0:
	nop	 stack+=[1 + r0]
	add	 r1, r0, r3
	shr.s	96, r3, r3
   ...
	near_call	r0, @__farcall, @DEFAULT_UNWIND
   ...
.func_end0:

__farcall:
.func_begin2:
.tmp0:
	far_call	r1, r2, @.BB2_2
.tmp1:
	add	 1, r0, r2
	ret
.BB2_2:
.tmp2:
	add	 r0, r0, r2
	ret
.func_end2:
...
```

Notice how instead of calling `far_call` directly, we are calling `near_call` which in turn calls `far_call`. This is because `far_call` does not return a value, so we need to wrap it in a `near_call` to return a boolean indicating success wheter the call was successful (1) or not (0).

### Data passing between contracts

To send and receive (read only) data between contracts, we make use of Fat Pointers, these are the second type of value that the VM can handle, this type is composed of four 32bit values:

- bits `0..31`: offset
- bits `32..63`: internal memory page ID
- bits `64…95`: starting address of the fragment
- bits `96…127`: length of the fragment

When choosing how to pass data to a contract (whether when calling or returning from a call) we have a choice:

- pass an existing fat pointer
- create a new fat pointer from a fragment of heap/auxheap.

This is handled by the `get_forward_memory_pointer` function TODO

A Fat Pointer will delimit a fragment accessible to other contract, accesses outside this fragment through a pointer yield zero. They also provide an offset inside this fragment which can be increased or decreased.

## Call Types

Regular, Mimic, and Delegate. Explain the differences between them and how MimicCalls are used to call constructors on behalf of the deployed contract.

## Precompiles and System calls

Explain how calls to precompiles work, use keccak as an example as it's used on every deployment (it goes to the `keccak.yul` contract which then uses the `precompile` opcode).
What are system contracts? What's a system call? Show some examples (deployer, nonce holder, L2BaseToken) and what they're used for.

## `context.get_context_u128` opcode, msg.value, payable functions

Explain what `msg.value` is in solidity, how that maps to `context.get_context_u128` and a small example showing how non-payable functions revert when `context.get_context_u128` is not set to zero on calls.

Show an example of the assembly generated by a function doing a `call` sending money and how it ends up calling the `MsgValueSimulator` (address `0x8009`, `32777` in decimal) which in turn calls the `L2BaseToken` contract. Something like this:

```
function sendMoney(address payable to) public payable {
  (bool success, bytes memory _data) = to.call{value: msg.value}("");
  require(success, "Failed to send Ether");
}
```

## Tracers and how to add prints

A `Tracer` should comply with the following trait
```
pub trait Tracer {
    fn before_execution(&mut self, _opcode: &Opcode, _vm: &mut VMState) -> Result<(), EraVmError>;
}
```

The `before_execution` function will be called on every loop just before the opcode execution.
Right now that is the only function the trait has, in the future more may be added as needed, like `before_decoding`, `after_decoding` or `after_execution`

An important Tracer is what we call the `PrintTracer`, with it we can print stuff on solidity contracts.

Here is an example of a contract with prints
```
pragma solidity >=0.4.16;

contract WithPrints {

    // This is for strings	
    function printIt(bytes32 toPrint) public {
        assembly {
            function $llvm_NoInline_llvm$_printString(__value) {
                let DEBUG_SLOT_OFFSET := mul(32, 32)
                    mstore(add(DEBUG_SLOT_OFFSET, 0x20), 0x00debdebdebdebdebdebdebdebdebdebdebdebdebdebdebdebdebdebdebdebdf)
                    mstore(add(DEBUG_SLOT_OFFSET, 0x40), __value)
                    mstore(DEBUG_SLOT_OFFSET, 0x4A15830341869CAA1E99840C97043A1EA15D2444DA366EFFF5C43B4BEF299681)
        }
            $llvm_NoInline_llvm$_printString(toPrint)
        }
    }
    // This is for numbers
   function printItNum(uint256 toPrint) public {
        assembly {
            function $llvm_NoInline_llvm$_printString(__value) {
                let DEBUG_SLOT_OFFSET := mul(32, 32)
                    mstore(add(DEBUG_SLOT_OFFSET, 0x20), 0x00debdebdebdebdebdebdebdebdebdebdebdebdebdebdebdebdebdebdebdebde)
                    mstore(add(DEBUG_SLOT_OFFSET, 0x40), __value)
                    mstore(DEBUG_SLOT_OFFSET, 0x4A15830341869CAA1E99840C97043A1EA15D2444DA366EFFF5C43B4BEF299681)
        }
            $llvm_NoInline_llvm$_printString(toPrint)
        }
    }

    function aFunction() public returns(uint64) {
        uint64 result = 42;
        printIt("RESULT");
        printItNum(result);
        return result;
    }
}
```

There are two types of prints, strings and numbers, for that we have printIt and printItNum respectively.
What these functions are doing is, they use a debug slot defined as 1024, on `debug_slot + 32` we store a value that indicates if the print is going to be a string or a number, then on `debug_slot + 64` we store the value itself, and on `debug_slot` we store a magic value.

Here is where the PrintTracer does its magic, before every execution it looks if the opcode executed is a `HeapWrite`, this is the opcode responsible for storing things in the Heap, which is in the end what we are doing with the `mstore`, if the value being written is the magic value and its being written on the debug slot, then we know we are in one of the print functions and we need to print the value.

So we get from the heap the values on `debug_slot + 32` and `debug_slot + 64`, with the first one we check if we have to print a string or a number, and we print the correspondent one.

Have in mind that currently, mainly because of compiler optimizations, some prints may not appear, specially if they are right after each other.

In order to perform prints, at the moment we need to change the following on `src/lib.rs`

```
fn run_opcodes(vm: VMState, storage: &mut dyn Storage) -> (ExecutionOutput, VMState) {
    run(vm.clone(), storage, &mut []).unwrap_or((ExecutionOutput::Panic, vm))
}
```

For

```
use tracers::print_tracer::PrintTracer;

...

fn run_opcodes(vm: VMState, storage: &mut dyn Storage) -> (ExecutionOutput, VMState) {
    let mut tracer = PrintTracer {};
    run(vm.clone(), storage, &mut [Box::new(&mut tracer)]).unwrap_or((ExecutionOutput::Panic, vm))
}
```
## Difference between a revert and a panic; exception handlers

Talk about what a revert and a panic are; what specifically can trigger a panic inside the VM. What's an exception handler? How are they managed on `CallFrame`s? Show some assembly example.

## Bootloader

TODO
Operator execution (transactions come in, get executed on the bootloader, state is suspended until new transaction shows up).
